#include <mom/cast.h>
/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <rpc/rpc.h>

bool_t
xdr_cast_type(xdrs, objp)
	register XDR *xdrs;
	cast_type *objp;
{

	if (!xdr_pointer(xdrs, (char **)objp, sizeof (struct cast_type_u), (xdrproc_t) xdr_cast_type_u))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_expr(xdrs, objp)
	register XDR *xdrs;
	cast_expr *objp;
{

	if (!xdr_pointer(xdrs, (char **)objp, sizeof (struct cast_expr_u), (xdrproc_t) xdr_cast_expr_u))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_stmt(xdrs, objp)
	register XDR *xdrs;
	cast_stmt *objp;
{

	if (!xdr_pointer(xdrs, (char **)objp, sizeof (struct cast_stmt_u), (xdrproc_t) xdr_cast_stmt_u))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_init(xdrs, objp)
	register XDR *xdrs;
	cast_init *objp;
{

	if (!xdr_pointer(xdrs, (char **)objp, sizeof (struct cast_init_u), (xdrproc_t) xdr_cast_init_u))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_template_arg(xdrs, objp)
	register XDR *xdrs;
	cast_template_arg *objp;
{

	if (!xdr_pointer(xdrs, (char **)objp, sizeof (struct cast_template_arg_u), (xdrproc_t) xdr_cast_template_arg_u))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_template_param_t(xdrs, objp)
	register XDR *xdrs;
	cast_template_param_t *objp;
{

	if (!xdr_pointer(xdrs, (char **)objp, sizeof (struct cast_template_param), (xdrproc_t) xdr_cast_template_param))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_template_arg_array(xdrs, objp)
	register XDR *xdrs;
	cast_template_arg_array *objp;
{

	if (!xdr_array(xdrs, (char **)&objp->cast_template_arg_array_val, (u_int *) &objp->cast_template_arg_array_len, ~0,
		sizeof (cast_template_arg), (xdrproc_t) xdr_cast_template_arg))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_scoped_name(xdrs, objp)
	register XDR *xdrs;
	cast_scoped_name *objp;
{

	if (!xdr_array(xdrs, (char **)&objp->cast_scoped_name_val, (u_int *) &objp->cast_scoped_name_len, ~0,
		sizeof (struct cast_name_s), (xdrproc_t) xdr_cast_name_s))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_scope(xdrs, objp)
	register XDR *xdrs;
	cast_scope *objp;
{

	if (!xdr_array(xdrs, (char **)&objp->cast_scope_val, (u_int *) &objp->cast_scope_len, ~0,
		sizeof (struct cast_def), (xdrproc_t) xdr_cast_def))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_def_t(xdrs, objp)
	register XDR *xdrs;
	cast_def_t *objp;
{

	if (!xdr_pointer(xdrs, (char **)objp, sizeof (struct cast_def), (xdrproc_t) xdr_cast_def))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_expr_array(xdrs, objp)
	register XDR *xdrs;
	cast_expr_array *objp;
{

	if (!xdr_array(xdrs, (char **)&objp->cast_expr_array_val, (u_int *) &objp->cast_expr_array_len, ~0,
		sizeof (cast_expr), (xdrproc_t) xdr_cast_expr))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_type_array(xdrs, objp)
	register XDR *xdrs;
	cast_type_array *objp;
{

	if (!xdr_array(xdrs, (char **)&objp->cast_type_array_val, (u_int *) &objp->cast_type_array_len, ~0,
		sizeof (cast_type), (xdrproc_t) xdr_cast_type))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_init_array(xdrs, objp)
	register XDR *xdrs;
	cast_init_array *objp;
{

	if (!xdr_array(xdrs, (char **)&objp->cast_init_array_val, (u_int *) &objp->cast_init_array_len, ~0,
		sizeof (cast_init), (xdrproc_t) xdr_cast_init))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_template_arg_kind(xdrs, objp)
	register XDR *xdrs;
	cast_template_arg_kind *objp;
{

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_template_arg_u(xdrs, objp)
	register XDR *xdrs;
	cast_template_arg_u *objp;
{

	if (!xdr_cast_template_arg_kind(xdrs, &objp->kind))
		return (FALSE);
	switch (objp->kind) {
	case CAST_TEMP_ARG_NAME:
		if (!xdr_cast_scoped_name(xdrs, &objp->cast_template_arg_u_u.name))
			return (FALSE);
		break;
	case CAST_TEMP_ARG_TYPE:
		if (!xdr_cast_type(xdrs, &objp->cast_template_arg_u_u.type))
			return (FALSE);
		break;
	case CAST_TEMP_ARG_EXPR:
		if (!xdr_cast_expr(xdrs, &objp->cast_template_arg_u_u.expr))
			return (FALSE);
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_cast_name_s(xdrs, objp)
	register XDR *xdrs;
	cast_name_s *objp;
{

	if (!xdr_string(xdrs, &objp->name, ~0))
		return (FALSE);
	if (!xdr_cast_template_arg_array(xdrs, &objp->args))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_primitive_kind(xdrs, objp)
	register XDR *xdrs;
	cast_primitive_kind *objp;
{

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_primitive_modifier(xdrs, objp)
	register XDR *xdrs;
	cast_primitive_modifier *objp;
{

	if (!xdr_u_int(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_primitive_type(xdrs, objp)
	register XDR *xdrs;
	cast_primitive_type *objp;
{

	if (!xdr_cast_primitive_kind(xdrs, &objp->kind))
		return (FALSE);
	if (!xdr_cast_primitive_modifier(xdrs, &objp->mod))
		return (FALSE);
	if (!xdr_cast_scoped_name(xdrs, &objp->name))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_enum_field(xdrs, objp)
	register XDR *xdrs;
	cast_enum_field *objp;
{

	if (!xdr_string(xdrs, &objp->name, ~0))
		return (FALSE);
	if (!xdr_cast_expr(xdrs, &objp->val))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_enum_type(xdrs, objp)
	register XDR *xdrs;
	cast_enum_type *objp;
{

	if (!xdr_cast_scoped_name(xdrs, &objp->name))
		return (FALSE);
	if (!xdr_array(xdrs, (char **)&objp->slots.slots_val, (u_int *) &objp->slots.slots_len, ~0,
		sizeof (cast_enum_field), (xdrproc_t) xdr_cast_enum_field))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_array_type(xdrs, objp)
	register XDR *xdrs;
	cast_array_type *objp;
{

	if (!xdr_cast_expr(xdrs, &objp->length))
		return (FALSE);
	if (!xdr_cast_type(xdrs, &objp->element_type))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_pointer_type(xdrs, objp)
	register XDR *xdrs;
	cast_pointer_type *objp;
{

	if (!xdr_cast_type(xdrs, &objp->target))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_reference_type(xdrs, objp)
	register XDR *xdrs;
	cast_reference_type *objp;
{

	if (!xdr_cast_type(xdrs, &objp->target))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_param_spec(xdrs, objp)
	register XDR *xdrs;
	cast_param_spec *objp;
{

	if (!xdr_u_int(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_param(xdrs, objp)
	register XDR *xdrs;
	cast_param *objp;
{

	if (!xdr_cast_param_spec(xdrs, &objp->spec))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->name, ~0))
		return (FALSE);
	if (!xdr_cast_type(xdrs, &objp->type))
		return (FALSE);
	if (!xdr_cast_init(xdrs, &objp->default_value))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_func_param(xdrs, objp)
	register XDR *xdrs;
	cast_func_param *objp;
{

	if (!xdr_cast_param(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_func_spec(xdrs, objp)
	register XDR *xdrs;
	cast_func_spec *objp;
{

	if (!xdr_u_int(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_func_type(xdrs, objp)
	register XDR *xdrs;
	cast_func_type *objp;
{

	if (!xdr_array(xdrs, (char **)&objp->params.params_val, (u_int *) &objp->params.params_len, ~0,
		sizeof (cast_func_param), (xdrproc_t) xdr_cast_func_param))
		return (FALSE);
	if (!xdr_cast_type(xdrs, &objp->return_type))
		return (FALSE);
	if (!xdr_cast_func_spec(xdrs, &objp->spec))
		return (FALSE);
	if (!xdr_cast_type_array(xdrs, &objp->exception_types))
		return (FALSE);
	if (!xdr_cast_expr_array(xdrs, &objp->initializers))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_parent_flags(xdrs, objp)
	register XDR *xdrs;
	cast_parent_flags *objp;
{

	if (!xdr_u_int(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_parent_spec(xdrs, objp)
	register XDR *xdrs;
	cast_parent_spec *objp;
{

	if (!xdr_cast_parent_flags(xdrs, &objp->flags))
		return (FALSE);
	if (!xdr_cast_scoped_name(xdrs, &objp->name))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_aggregate_kind(xdrs, objp)
	register XDR *xdrs;
	cast_aggregate_kind *objp;
{

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_aggregate_type(xdrs, objp)
	register XDR *xdrs;
	cast_aggregate_type *objp;
{

	if (!xdr_cast_aggregate_kind(xdrs, &objp->kind))
		return (FALSE);
	if (!xdr_cast_scoped_name(xdrs, &objp->name))
		return (FALSE);
	if (!xdr_array(xdrs, (char **)&objp->parents.parents_val, (u_int *) &objp->parents.parents_len, ~0,
		sizeof (cast_parent_spec), (xdrproc_t) xdr_cast_parent_spec))
		return (FALSE);
	if (!xdr_cast_scope(xdrs, &objp->scope))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_type_qualifier(xdrs, objp)
	register XDR *xdrs;
	cast_type_qualifier *objp;
{

	if (!xdr_int(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_qualified_type(xdrs, objp)
	register XDR *xdrs;
	cast_qualified_type *objp;
{

	if (!xdr_cast_type_qualifier(xdrs, &objp->qual))
		return (FALSE);
	if (!xdr_cast_type(xdrs, &objp->actual))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_template_param_kind(xdrs, objp)
	register XDR *xdrs;
	cast_template_param_kind *objp;
{

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_template_param_u(xdrs, objp)
	register XDR *xdrs;
	cast_template_param_u *objp;
{

	if (!xdr_cast_template_param_kind(xdrs, &objp->kind))
		return (FALSE);
	switch (objp->kind) {
	case CAST_TEMP_PARAM_TYPE:
		if (!xdr_cast_type(xdrs, &objp->cast_template_param_u_u.type_param))
			return (FALSE);
		break;
	case CAST_TEMP_PARAM_CLASS:
		break;
	case CAST_TEMP_PARAM_TYPENAME:
		break;
	case CAST_TEMP_PARAM_TEMPLATE:
		if (!xdr_array(xdrs, (char **)&objp->cast_template_param_u_u.params.params_val, (u_int *) &objp->cast_template_param_u_u.params.params_len, ~0,
			sizeof (cast_template_param_t), (xdrproc_t) xdr_cast_template_param_t))
			return (FALSE);
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_cast_template_param(xdrs, objp)
	register XDR *xdrs;
	cast_template_param *objp;
{

	if (!xdr_string(xdrs, &objp->name, ~0))
		return (FALSE);
	if (!xdr_cast_template_param_u(xdrs, &objp->u))
		return (FALSE);
	if (!xdr_cast_template_arg(xdrs, &objp->default_value))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_template_flags(xdrs, objp)
	register XDR *xdrs;
	cast_template_flags *objp;
{

	if (!xdr_u_int(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_template_type(xdrs, objp)
	register XDR *xdrs;
	cast_template_type *objp;
{

	if (!xdr_cast_template_flags(xdrs, &objp->flags))
		return (FALSE);
	if (!xdr_array(xdrs, (char **)&objp->params.params_val, (u_int *) &objp->params.params_len, ~0,
		sizeof (cast_template_param), (xdrproc_t) xdr_cast_template_param))
		return (FALSE);
	if (!xdr_cast_type(xdrs, &objp->def))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_type_kind(xdrs, objp)
	register XDR *xdrs;
	cast_type_kind *objp;
{

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_type_u(xdrs, objp)
	register XDR *xdrs;
	cast_type_u *objp;
{

	if (!xdr_cast_type_kind(xdrs, &objp->kind))
		return (FALSE);
	switch (objp->kind) {
	case CAST_TYPE_NAME:
		if (!xdr_cast_scoped_name(xdrs, &objp->cast_type_u_u.name))
			return (FALSE);
		break;
	case CAST_TYPE_PRIMITIVE:
		if (!xdr_cast_primitive_type(xdrs, &objp->cast_type_u_u.primitive_type))
			return (FALSE);
		break;
	case CAST_TYPE_POINTER:
		if (!xdr_cast_pointer_type(xdrs, &objp->cast_type_u_u.pointer_type))
			return (FALSE);
		break;
	case CAST_TYPE_ARRAY:
		if (!xdr_cast_array_type(xdrs, &objp->cast_type_u_u.array_type))
			return (FALSE);
		break;
	case CAST_TYPE_FUNCTION:
		if (!xdr_cast_func_type(xdrs, &objp->cast_type_u_u.func_type))
			return (FALSE);
		break;
	case CAST_TYPE_ENUM:
		if (!xdr_cast_enum_type(xdrs, &objp->cast_type_u_u.enum_type))
			return (FALSE);
		break;
	case CAST_TYPE_STRUCT_NAME:
		if (!xdr_cast_scoped_name(xdrs, &objp->cast_type_u_u.struct_name))
			return (FALSE);
		break;
	case CAST_TYPE_UNION_NAME:
		if (!xdr_cast_scoped_name(xdrs, &objp->cast_type_u_u.union_name))
			return (FALSE);
		break;
	case CAST_TYPE_ENUM_NAME:
		if (!xdr_cast_scoped_name(xdrs, &objp->cast_type_u_u.enum_name))
			return (FALSE);
		break;
	case CAST_TYPE_VOID:
		break;
	case CAST_TYPE_NULL:
		break;
	case CAST_TYPE_QUALIFIED:
		if (!xdr_cast_qualified_type(xdrs, &objp->cast_type_u_u.qualified))
			return (FALSE);
		break;
	case CAST_TYPE_AGGREGATE:
		if (!xdr_cast_aggregate_type(xdrs, &objp->cast_type_u_u.agg_type))
			return (FALSE);
		break;
	case CAST_TYPE_CLASS_NAME:
		if (!xdr_cast_scoped_name(xdrs, &objp->cast_type_u_u.class_name))
			return (FALSE);
		break;
	case CAST_TYPE_REFERENCE:
		if (!xdr_cast_reference_type(xdrs, &objp->cast_type_u_u.reference_type))
			return (FALSE);
		break;
	case CAST_TYPE_TYPENAME:
		if (!xdr_cast_scoped_name(xdrs, &objp->cast_type_u_u.typename_name))
			return (FALSE);
		break;
	case CAST_TYPE_TEMPLATE:
		if (!xdr_cast_template_type(xdrs, &objp->cast_type_u_u.template_type))
			return (FALSE);
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_cast_lit_prim_u(xdrs, objp)
	register XDR *xdrs;
	cast_lit_prim_u *objp;
{

	if (!xdr_cast_primitive_kind(xdrs, &objp->kind))
		return (FALSE);
	switch (objp->kind) {
	case CAST_PRIM_CHAR:
		if (!xdr_char(xdrs, &objp->cast_lit_prim_u_u.c))
			return (FALSE);
		break;
	case CAST_PRIM_INT:
		if (!xdr_long(xdrs, &objp->cast_lit_prim_u_u.i))
			return (FALSE);
		break;
	case CAST_PRIM_FLOAT:
		if (!xdr_float(xdrs, &objp->cast_lit_prim_u_u.f))
			return (FALSE);
		break;
	case CAST_PRIM_DOUBLE:
		if (!xdr_double(xdrs, &objp->cast_lit_prim_u_u.d))
			return (FALSE);
		break;
	case CAST_PRIM_BOOL:
		if (!xdr_char(xdrs, &objp->cast_lit_prim_u_u.b))
			return (FALSE);
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_cast_lit_prim(xdrs, objp)
	register XDR *xdrs;
	cast_lit_prim *objp;
{

	if (!xdr_cast_primitive_modifier(xdrs, &objp->mod))
		return (FALSE);
	if (!xdr_cast_lit_prim_u(xdrs, &objp->u))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_expr_call(xdrs, objp)
	register XDR *xdrs;
	cast_expr_call *objp;
{

	if (!xdr_cast_expr(xdrs, &objp->func))
		return (FALSE);
	if (!xdr_cast_expr_array(xdrs, &objp->params))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_expr_sel(xdrs, objp)
	register XDR *xdrs;
	cast_expr_sel *objp;
{

	if (!xdr_cast_expr(xdrs, &objp->var))
		return (FALSE);
	if (!xdr_cast_scoped_name(xdrs, &objp->member))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_unary_op(xdrs, objp)
	register XDR *xdrs;
	cast_unary_op *objp;
{

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_unary_expr(xdrs, objp)
	register XDR *xdrs;
	cast_unary_expr *objp;
{

	if (!xdr_cast_unary_op(xdrs, &objp->op))
		return (FALSE);
	if (!xdr_cast_expr(xdrs, &objp->expr))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_expr_cast(xdrs, objp)
	register XDR *xdrs;
	cast_expr_cast *objp;
{

	if (!xdr_cast_expr(xdrs, &objp->expr))
		return (FALSE);
	if (!xdr_cast_type(xdrs, &objp->type))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_binary_op(xdrs, objp)
	register XDR *xdrs;
	cast_binary_op *objp;
{

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_binary_expr(xdrs, objp)
	register XDR *xdrs;
	cast_binary_expr *objp;
{

	if (!xdr_cast_binary_op(xdrs, &objp->op))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->expr, 2,
		sizeof (cast_expr), (xdrproc_t) xdr_cast_expr))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_cond_expr(xdrs, objp)
	register XDR *xdrs;
	cast_cond_expr *objp;
{

	if (!xdr_cast_expr(xdrs, &objp->test))
		return (FALSE);
	if (!xdr_cast_expr(xdrs, &objp->true_expr))
		return (FALSE);
	if (!xdr_cast_expr(xdrs, &objp->false_expr))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_op_new_expr(xdrs, objp)
	register XDR *xdrs;
	cast_op_new_expr *objp;
{

	if (!xdr_cast_expr(xdrs, &objp->placement))
		return (FALSE);
	if (!xdr_cast_type(xdrs, &objp->type))
		return (FALSE);
	if (!xdr_cast_init(xdrs, &objp->init))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_op_delete_expr(xdrs, objp)
	register XDR *xdrs;
	cast_op_delete_expr *objp;
{

	if (!xdr_long(xdrs, &objp->array))
		return (FALSE);
	if (!xdr_cast_expr(xdrs, &objp->expr))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_expr_kind(xdrs, objp)
	register XDR *xdrs;
	cast_expr_kind *objp;
{

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_expr_u(xdrs, objp)
	register XDR *xdrs;
	cast_expr_u *objp;
{

	if (!xdr_cast_expr_kind(xdrs, &objp->kind))
		return (FALSE);
	switch (objp->kind) {
	case CAST_EXPR_NAME:
		if (!xdr_cast_scoped_name(xdrs, &objp->cast_expr_u_u.name))
			return (FALSE);
		break;
	case CAST_EXPR_LIT_PRIM:
		if (!xdr_cast_lit_prim(xdrs, &objp->cast_expr_u_u.lit_prim))
			return (FALSE);
		break;
	case CAST_EXPR_LIT_STRING:
		if (!xdr_string(xdrs, &objp->cast_expr_u_u.lit_string, ~0))
			return (FALSE);
		break;
	case CAST_EXPR_CALL:
		if (!xdr_cast_expr_call(xdrs, &objp->cast_expr_u_u.call))
			return (FALSE);
		break;
	case CAST_EXPR_SEL:
		if (!xdr_cast_expr_sel(xdrs, &objp->cast_expr_u_u.sel))
			return (FALSE);
		break;
	case CAST_EXPR_UNARY:
		if (!xdr_cast_unary_expr(xdrs, &objp->cast_expr_u_u.unary))
			return (FALSE);
		break;
	case CAST_EXPR_CAST:
		if (!xdr_cast_expr_cast(xdrs, &objp->cast_expr_u_u.cast))
			return (FALSE);
		break;
	case CAST_EXPR_SIZEOF_EXPR:
		if (!xdr_cast_expr(xdrs, &objp->cast_expr_u_u.sizeof_expr))
			return (FALSE);
		break;
	case CAST_EXPR_SIZEOF_TYPE:
		if (!xdr_cast_type(xdrs, &objp->cast_expr_u_u.sizeof_type))
			return (FALSE);
		break;
	case CAST_EXPR_BINARY:
		if (!xdr_cast_binary_expr(xdrs, &objp->cast_expr_u_u.binary))
			return (FALSE);
		break;
	case CAST_EXPR_OP_ASSIGN:
		if (!xdr_cast_binary_expr(xdrs, &objp->cast_expr_u_u.op_assign))
			return (FALSE);
		break;
	case CAST_EXPR_COND:
		if (!xdr_cast_cond_expr(xdrs, &objp->cast_expr_u_u.cond))
			return (FALSE);
		break;
	case CAST_EXPR_CONST_NAME:
		if (!xdr_cast_scoped_name(xdrs, &objp->cast_expr_u_u.const_name))
			return (FALSE);
		break;
	case CAST_EXPR_CONST_CAST:
		if (!xdr_cast_expr_cast(xdrs, &objp->cast_expr_u_u.c_cast))
			return (FALSE);
		break;
	case CAST_EXPR_DYNAMIC_CAST:
		if (!xdr_cast_expr_cast(xdrs, &objp->cast_expr_u_u.d_cast))
			return (FALSE);
		break;
	case CAST_EXPR_REINTERPRET_CAST:
		if (!xdr_cast_expr_cast(xdrs, &objp->cast_expr_u_u.r_cast))
			return (FALSE);
		break;
	case CAST_EXPR_STATIC_CAST:
		if (!xdr_cast_expr_cast(xdrs, &objp->cast_expr_u_u.s_cast))
			return (FALSE);
		break;
	case CAST_EXPR_OP_NEW:
		if (!xdr_cast_op_new_expr(xdrs, &objp->cast_expr_u_u.op_new))
			return (FALSE);
		break;
	case CAST_EXPR_OP_DELETE:
		if (!xdr_cast_op_delete_expr(xdrs, &objp->cast_expr_u_u.op_delete))
			return (FALSE);
		break;
	case CAST_EXPR_TYPEID_EXPR:
		if (!xdr_cast_expr(xdrs, &objp->cast_expr_u_u.typeid_expr))
			return (FALSE);
		break;
	case CAST_EXPR_TYPEID_TYPE:
		if (!xdr_cast_type(xdrs, &objp->cast_expr_u_u.typeid_type))
			return (FALSE);
		break;
	case CAST_EXPR_TYPE:
		if (!xdr_cast_type(xdrs, &objp->cast_expr_u_u.type_expr))
			return (FALSE);
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_cast_block_flags(xdrs, objp)
	register XDR *xdrs;
	cast_block_flags *objp;
{

	if (!xdr_u_int(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_block(xdrs, objp)
	register XDR *xdrs;
	cast_block *objp;
{

	if (!xdr_cast_scope(xdrs, &objp->scope))
		return (FALSE);
	if (!xdr_array(xdrs, (char **)&objp->initials.initials_val, (u_int *) &objp->initials.initials_len, ~0,
		sizeof (cast_stmt), (xdrproc_t) xdr_cast_stmt))
		return (FALSE);
	if (!xdr_array(xdrs, (char **)&objp->stmts.stmts_val, (u_int *) &objp->stmts.stmts_len, ~0,
		sizeof (cast_stmt), (xdrproc_t) xdr_cast_stmt))
		return (FALSE);
	if (!xdr_cast_block_flags(xdrs, &objp->flags))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_if(xdrs, objp)
	register XDR *xdrs;
	cast_if *objp;
{

	if (!xdr_cast_expr(xdrs, &objp->test))
		return (FALSE);
	if (!xdr_cast_stmt(xdrs, &objp->true_stmt))
		return (FALSE);
	if (!xdr_cast_stmt(xdrs, &objp->false_stmt))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_while(xdrs, objp)
	register XDR *xdrs;
	cast_while *objp;
{

	if (!xdr_cast_expr(xdrs, &objp->test))
		return (FALSE);
	if (!xdr_cast_stmt(xdrs, &objp->stmt))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_for(xdrs, objp)
	register XDR *xdrs;
	cast_for *objp;
{

	if (!xdr_cast_expr(xdrs, &objp->init))
		return (FALSE);
	if (!xdr_cast_expr(xdrs, &objp->test))
		return (FALSE);
	if (!xdr_cast_expr(xdrs, &objp->iter))
		return (FALSE);
	if (!xdr_cast_stmt(xdrs, &objp->stmt))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_switch(xdrs, objp)
	register XDR *xdrs;
	cast_switch *objp;
{

	if (!xdr_cast_expr(xdrs, &objp->test))
		return (FALSE);
	if (!xdr_cast_stmt(xdrs, &objp->stmt))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_label(xdrs, objp)
	register XDR *xdrs;
	cast_label *objp;
{

	if (!xdr_string(xdrs, &objp->label, ~0))
		return (FALSE);
	if (!xdr_cast_stmt(xdrs, &objp->stmt))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->users))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_case(xdrs, objp)
	register XDR *xdrs;
	cast_case *objp;
{

	if (!xdr_cast_expr(xdrs, &objp->label))
		return (FALSE);
	if (!xdr_cast_stmt(xdrs, &objp->stmt))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_catch(xdrs, objp)
	register XDR *xdrs;
	cast_catch *objp;
{

	if (!xdr_cast_type(xdrs, &objp->type))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->name, ~0))
		return (FALSE);
	if (!xdr_cast_stmt(xdrs, &objp->block))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_try(xdrs, objp)
	register XDR *xdrs;
	cast_try *objp;
{

	if (!xdr_cast_stmt(xdrs, &objp->block))
		return (FALSE);
	if (!xdr_array(xdrs, (char **)&objp->handlers.handlers_val, (u_int *) &objp->handlers.handlers_len, ~0,
		sizeof (cast_catch), (xdrproc_t) xdr_cast_catch))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_handler_arg(xdrs, objp)
	register XDR *xdrs;
	cast_handler_arg *objp;
{

	if (!xdr_string(xdrs, objp, ~0))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_handler(xdrs, objp)
	register XDR *xdrs;
	cast_handler *objp;
{

	if (!xdr_string(xdrs, &objp->name, ~0))
		return (FALSE);
	if (!xdr_array(xdrs, (char **)&objp->args.args_val, (u_int *) &objp->args.args_len, ~0,
		sizeof (cast_handler_arg), (xdrproc_t) xdr_cast_handler_arg))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_stmt_kind(xdrs, objp)
	register XDR *xdrs;
	cast_stmt_kind *objp;
{

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_stmt_u(xdrs, objp)
	register XDR *xdrs;
	cast_stmt_u *objp;
{

	if (!xdr_cast_stmt_kind(xdrs, &objp->kind))
		return (FALSE);
	switch (objp->kind) {
	case CAST_STMT_EXPR:
		if (!xdr_cast_expr(xdrs, &objp->cast_stmt_u_u.expr))
			return (FALSE);
		break;
	case CAST_STMT_BLOCK:
		if (!xdr_cast_block(xdrs, &objp->cast_stmt_u_u.block))
			return (FALSE);
		break;
	case CAST_STMT_IF:
		if (!xdr_cast_if(xdrs, &objp->cast_stmt_u_u.s_if))
			return (FALSE);
		break;
	case CAST_STMT_WHILE:
		if (!xdr_cast_while(xdrs, &objp->cast_stmt_u_u.s_while))
			return (FALSE);
		break;
	case CAST_STMT_DO_WHILE:
		if (!xdr_cast_while(xdrs, &objp->cast_stmt_u_u.s_do_while))
			return (FALSE);
		break;
	case CAST_STMT_FOR:
		if (!xdr_cast_for(xdrs, &objp->cast_stmt_u_u.s_for))
			return (FALSE);
		break;
	case CAST_STMT_SWITCH:
		if (!xdr_cast_switch(xdrs, &objp->cast_stmt_u_u.s_switch))
			return (FALSE);
		break;
	case CAST_STMT_BREAK:
		break;
	case CAST_STMT_CONTINUE:
		break;
	case CAST_STMT_GOTO:
		if (!xdr_string(xdrs, &objp->cast_stmt_u_u.goto_label, ~0))
			return (FALSE);
		break;
	case CAST_STMT_LABEL:
		if (!xdr_cast_label(xdrs, &objp->cast_stmt_u_u.s_label))
			return (FALSE);
		break;
	case CAST_STMT_CASE:
		if (!xdr_cast_case(xdrs, &objp->cast_stmt_u_u.s_case))
			return (FALSE);
		break;
	case CAST_STMT_DEFAULT:
		if (!xdr_cast_stmt(xdrs, &objp->cast_stmt_u_u.default_stmt))
			return (FALSE);
		break;
	case CAST_STMT_RETURN:
		if (!xdr_cast_expr(xdrs, &objp->cast_stmt_u_u.return_expr))
			return (FALSE);
		break;
	case CAST_STMT_TEXT:
		if (!xdr_string(xdrs, &objp->cast_stmt_u_u.text, ~0))
			return (FALSE);
		break;
	case CAST_STMT_NULL:
		break;
	case CAST_STMT_EMPTY:
		break;
	case CAST_STMT_TRY:
		if (!xdr_cast_try(xdrs, &objp->cast_stmt_u_u.try_block))
			return (FALSE);
		break;
	case CAST_STMT_THROW:
		if (!xdr_cast_expr(xdrs, &objp->cast_stmt_u_u.throw_expr))
			return (FALSE);
		break;
	case CAST_STMT_DECL:
		if (!xdr_cast_scope(xdrs, &objp->cast_stmt_u_u.decl))
			return (FALSE);
		break;
	case CAST_STMT_HANDLER:
		if (!xdr_cast_handler(xdrs, &objp->cast_stmt_u_u.handler))
			return (FALSE);
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_cast_func_def(xdrs, objp)
	register XDR *xdrs;
	cast_func_def *objp;
{

	if (!xdr_cast_func_type(xdrs, &objp->type))
		return (FALSE);
	if (!xdr_cast_block(xdrs, &objp->block))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_init_kind(xdrs, objp)
	register XDR *xdrs;
	cast_init_kind *objp;
{

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_init_u(xdrs, objp)
	register XDR *xdrs;
	cast_init_u *objp;
{

	if (!xdr_cast_init_kind(xdrs, &objp->kind))
		return (FALSE);
	switch (objp->kind) {
	case CAST_INIT_EXPR:
		if (!xdr_cast_expr(xdrs, &objp->cast_init_u_u.expr))
			return (FALSE);
		break;
	case CAST_INIT_AGGREGATE:
		if (!xdr_cast_init_array(xdrs, &objp->cast_init_u_u.subs))
			return (FALSE);
		break;
	case CAST_INIT_CONSTRUCT:
		if (!xdr_cast_expr_array(xdrs, &objp->cast_init_u_u.exprs))
			return (FALSE);
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_cast_var_def(xdrs, objp)
	register XDR *xdrs;
	cast_var_def *objp;
{

	if (!xdr_cast_type(xdrs, &objp->type))
		return (FALSE);
	if (!xdr_cast_init(xdrs, &objp->init))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_include(xdrs, objp)
	register XDR *xdrs;
	cast_include *objp;
{

	if (!xdr_string(xdrs, &objp->filename, ~0))
		return (FALSE);
	if (!xdr_bool(xdrs, &objp->system_only))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_direct(xdrs, objp)
	register XDR *xdrs;
	cast_direct *objp;
{

	if (!xdr_string(xdrs, &objp->code_string, ~0))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_storage_class(xdrs, objp)
	register XDR *xdrs;
	cast_storage_class *objp;
{

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_using_kind(xdrs, objp)
	register XDR *xdrs;
	cast_using_kind *objp;
{

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_def_kind(xdrs, objp)
	register XDR *xdrs;
	cast_def_kind *objp;
{

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_def_u(xdrs, objp)
	register XDR *xdrs;
	cast_def_u *objp;
{

	if (!xdr_cast_def_kind(xdrs, &objp->kind))
		return (FALSE);
	switch (objp->kind) {
	case CAST_TYPEDEF:
		if (!xdr_cast_type(xdrs, &objp->cast_def_u_u.typedef_type))
			return (FALSE);
		break;
	case CAST_TYPE:
		if (!xdr_cast_type(xdrs, &objp->cast_def_u_u.type))
			return (FALSE);
		break;
	case CAST_FUNC_DECL:
		if (!xdr_cast_func_type(xdrs, &objp->cast_def_u_u.func_type))
			return (FALSE);
		break;
	case CAST_FUNC_DEF:
		if (!xdr_cast_func_def(xdrs, &objp->cast_def_u_u.func_def))
			return (FALSE);
		break;
	case CAST_VAR_DECL:
		if (!xdr_cast_type(xdrs, &objp->cast_def_u_u.var_type))
			return (FALSE);
		break;
	case CAST_VAR_DEF:
		if (!xdr_cast_var_def(xdrs, &objp->cast_def_u_u.var_def))
			return (FALSE);
		break;
	case CAST_DEFINE:
		if (!xdr_cast_expr(xdrs, &objp->cast_def_u_u.define_as))
			return (FALSE);
		break;
	case CAST_INCLUDE:
		if (!xdr_cast_include(xdrs, &objp->cast_def_u_u.include))
			return (FALSE);
		break;
	case CAST_DIRECT_CODE:
		if (!xdr_cast_direct(xdrs, &objp->cast_def_u_u.direct))
			return (FALSE);
		break;
	case CAST_NAMESPACE:
		if (!xdr_pointer(xdrs, (char **)&objp->cast_def_u_u.new_namespace, sizeof (cast_scope), (xdrproc_t) xdr_cast_scope))
			return (FALSE);
		break;
	case CAST_USING:
		if (!xdr_cast_using_kind(xdrs, &objp->cast_def_u_u.using_scope))
			return (FALSE);
		break;
	case CAST_LINKAGE:
		if (!xdr_pointer(xdrs, (char **)&objp->cast_def_u_u.linkage, sizeof (cast_scope), (xdrproc_t) xdr_cast_scope))
			return (FALSE);
		break;
	case CAST_FRIEND:
		if (!xdr_cast_type(xdrs, &objp->cast_def_u_u.friend_decl))
			return (FALSE);
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_cast_def_protection(xdrs, objp)
	register XDR *xdrs;
	cast_def_protection *objp;
{

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_def(xdrs, objp)
	register XDR *xdrs;
	cast_def *objp;
{

	if (!xdr_cast_scoped_name(xdrs, &objp->name))
		return (FALSE);
	if (!xdr_cast_storage_class(xdrs, &objp->sc))
		return (FALSE);
	if (!xdr_cast_def_u(xdrs, &objp->u))
		return (FALSE);
	if (!xdr_data_channel_index(xdrs, &objp->channel))
		return (FALSE);
	if (!xdr_cast_def_protection(xdrs, &objp->protection))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_cast_1(xdrs, objp)
	register XDR *xdrs;
	cast_1 *objp;
{

	if (!xdr_cast_scope(xdrs, objp))
		return (FALSE);
	return (TRUE);
}
